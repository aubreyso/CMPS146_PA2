from math import sqrtfrom heapq import heappop, heappushdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = []    search_success = False    # ==========================================    # FIND BOXES THAT CONTAIN SRC AND DST POINTS    # ==========================================    # iterate through list of boxes    src_box = None    dst_box = None    for box in mesh["boxes"]:        # box : (x1, x2, y1, y2)        # src_point X check        if (box[0] <= source_point[0] and source_point[0] <= box[1]):            # src_point Y check            if (box[2] <= source_point[1] and source_point[1] <= box[3]):                src_box = box        # dst_point X check        if (box[0] <= destination_point[0] and destination_point[0] <= box[1]):            # dst_point Y check            if (box[2] <= destination_point[1] and destination_point[1] <= box[3]):                dst_box = box    # return if points are inside walls    if not (src_box and dst_box):        return path, boxes    # =================================================    # RUN BIDIRECTIONAL A*, TERMINATING IF SEARCHS MEET    # =================================================    # create frontier (priority queue) + push start to queue    frontier = []    heappush(frontier, (0, src_box, 'dst'))    heappush(frontier, (0, dst_box, 'src'))    # create dicts for maintaining paths, costs, and detail_points    # f_ -> forward search from src    # b_ -> backward search from dst    f_came_from = {}    f_cost_so_far = {}    f_detail_points = {}    b_came_from = {}    b_cost_so_far = {}    b_detail_points = {}    # update dict values for start    f_came_from[src_box] = None    f_cost_so_far[src_box] = 0    b_came_from[dst_box] = None    b_cost_so_far[dst_box] = 0    f_detail_points[src_box] = source_point    b_detail_points[dst_box] = destination_point    # while queue not empty    while frontier:        # get current box        current_prio, current_box, current_goal = heappop(frontier)        # designate which dicts to access based on current goal        if current_goal == 'dst':            came_from = f_came_from            n_came_from = b_came_from            cost_so_far = f_cost_so_far            goal_point = destination_point            detail_points = f_detail_points        elif current_goal == 'src':            came_from = b_came_from            n_came_from = f_came_from            cost_so_far = b_cost_so_far            goal_point = source_point            detail_points = b_detail_points        # append current_box to list of found boxes if first encounter        if current_box not in boxes:            boxes.append(current_box)        # if search directions meet, terminate search        if current_box in n_came_from:            search_success = True            break        # else enqueue neighbors        for next_box in mesh["adj"][current_box]:            # determine where detail_point for current_box should be placed            # compute x,y ranges of border edge             x_range = [max(current_box[0], next_box[0]), min(current_box[1], next_box[1])]            y_range = [max(current_box[2], next_box[2]), min(current_box[3], next_box[3])]            # one corner of border edge            mini = (x_range[0], y_range[0])            # other corner of border edge            maxi = (x_range[1], y_range[1])            # project previous point to border edge            if y_range[0] == y_range[1]:                midi = (detail_points[current_box][0], y_range[0])            elif x_range[0] == x_range[1]:                midi = (x_range[0], detail_points[current_box][1])            # get distances to mini, midi, maxi            mini_dist = get_distance(mini, detail_points[current_box])            maxi_dist = get_distance(maxi, detail_points[current_box])            midi_dist = get_distance(midi, detail_points[current_box])            # if straight projection is legal, use it            if mini[0]<midi[0] and midi[0]<maxi[0] or mini[1]<midi[1] and midi[1]<maxi[1]:                detail_point = midi            # otherwise, pick best out of (mini, maxi)            else:                if min(mini_dist, maxi_dist) == mini_dist:                    detail_point = mini                if min(mini_dist, maxi_dist) == maxi_dist:                    detail_point = maxi                        # now we have the detail_point which nets shortest distance into this box            # compute new cost            new_add = get_distance(detail_points[current_box], detail_point)            new_cost = cost_so_far[current_box] + new_add            # if next_box not found or has better cost            if next_box not in came_from or new_cost < cost_so_far[next_box]:                # update detail_point                detail_points[next_box] = detail_point                # update cost_so_far                cost_so_far[next_box] = new_cost                # update priority queue                remaining_estimate = get_distance(detail_point, goal_point)                heappush(frontier, (new_cost+remaining_estimate, next_box, current_goal))                came_from[next_box] = current_box    # =====================================    # RECONSTRUCT PATH IF SEARCH SUCCESSFUL    # =====================================    if search_success:        # line segment where both searches meet        path.append((f_detail_points[current_box], b_detail_points[current_box]))                # line segments for forward search (src to current)        prev_box = current_box        while prev_box != src_box:            path.append((f_detail_points[prev_box], f_detail_points[f_came_from[prev_box]]))            prev_box = f_came_from[prev_box]        # line segments for backward search (dst to current)        prev_box = current_box        while prev_box != dst_box:            path.append((b_detail_points[prev_box], b_detail_points[b_came_from[prev_box]]))            prev_box = b_came_from[prev_box]    # ===================================    # SEND MESSAGE IF SEARCH UNSUCCESSFUL    # ===================================    else:        print("No path!")    # =============    # RETURN VALUES    # =============    return path, boxes# returns the distance between two points (tuples)def get_distance(pointA, pointB):    return sqrt((pointA[0]-pointB[0])**2 + (pointA[1]-pointB[1])**2)