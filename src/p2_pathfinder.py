def find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = []        # FIND BOXES THAT CONTAIN SRC AND DST POINTS    # iterate through list of boxes    # current search: O(n) linear search    src_box = None    dst_box = None    for box in mesh["boxes"]:        # box : (x1, x2, y1, y2)        # src_point X check        if (box[0] <= source_point[0] and source_point[0] <= box[1]):            # src_point Y check            if (box[2] <= source_point[1] and source_point[1] <= box[3]):                src_box = box        # dst_point X check        if (box[0] <= destination_point[0] and destination_point[0] <= box[1]):            # dst_point Y check            if (box[2] <= destination_point[1] and destination_point[1] <= box[3]):                dst_box = box    # return if points are inside walls    if not (src_box and dst_box):        return path, boxes    # FIND SEQUENCE OF BOXES THAT REACHES DST FROM SRC    # (src_box, dst_box, mesh)    # current search: breadth first    frontier = []    frontier.append(src_box)    came_from = {}    came_from[src_box] = None    while frontier:        current_box = frontier.pop(0)        #boxes[box] = None        boxes.append(current_box)        if current_box == dst_box:            break        for next_box in mesh["adj"][current_box]:            if next_box not in came_from:                frontier.append(next_box)                came_from[next_box] = current_box        # UPDATE PATH    if dst_box not in came_from:        print("No path!")    else:        prev_box = dst_box        while not prev_box == src_box:            # get point of prev            pointX = ((prev_box[0]+prev_box[1])/2)            pointY = ((prev_box[2]+prev_box[3])/2)            pointA = (pointX, pointY)            # get point of came_from            pointX = ((came_from[prev_box][0]+came_from[prev_box][1])/2)            pointY = ((came_from[prev_box][2]+came_from[prev_box][3])/2)            pointB = (pointX, pointY)            # add segment to path            path.append((pointA, pointB))            # "iterate" prev_box            prev_box = came_from[prev_box]    # RETURN VALUES    return path, boxes