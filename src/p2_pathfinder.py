from math import sqrtfrom heapq import heappop, heappushdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = []        # FIND BOXES THAT CONTAIN SRC AND DST POINTS    # iterate through list of boxes    # current search: O(n) linear search    src_box = None    dst_box = None    for box in mesh["boxes"]:        # box : (x1, x2, y1, y2)        # src_point X check        if (box[0] <= source_point[0] and source_point[0] <= box[1]):            # src_point Y check            if (box[2] <= source_point[1] and source_point[1] <= box[3]):                src_box = box        # dst_point X check        if (box[0] <= destination_point[0] and destination_point[0] <= box[1]):            # dst_point Y check            if (box[2] <= destination_point[1] and destination_point[1] <= box[3]):                dst_box = box    # return if points are inside walls    if not (src_box and dst_box):        return path, boxes    # FIND SEQUENCE OF BOXES THAT REACHES DST FROM SRC    # (src_box, dst_box, mesh)    # current search: breadth first    """frontier = []    frontier.append(src_box)    came_from = {}    came_from[src_box] = None    detail_points = {}    detail_points[src_box] = source_point    # while frontier not empty    while frontier:        # dequeue item from frontier        current_box = frontier.pop(0)        boxes.append(current_box)                # early exit        #if current_box == dst_box:        #    break        # else search adjacent boxes        for next_box in mesh["adj"][current_box]:            if next_box not in came_from:                # legal line segment                 x_range = [max(current_box[0], next_box[0]), min(current_box[1], next_box[1])]                y_range = [max(current_box[2], next_box[2]), min(current_box[3], next_box[3])]                detail_points[next_box] = ((x_range[0] + x_range[1])/2, (y_range[0] + y_range[1])/2)                # true euclidian later                # add adjacents                frontier.append(next_box)                came_from[next_box] = current_box"""        # djikstra    # create frontier (priority queue) + push start to queue    frontier = []    heappush(frontier, src_box)    #create dicts for maintaining paths, costs, and detail_points    came_from = {}    cost_so_far = {}    detail_points = {}    # update dict values for start    came_from[src_box] = None    cost_so_far[src_box] = 0    detail_points[src_box] = source_point    # while queue not empty    while frontier:        # get current box        current_box = heappop(frontier)        boxes.append(current_box)        # if goal found, exit early        if current_box == dst_box:            break        # else        for next_box in mesh["adj"][current_box]:            # get detail point for next box             x_range = [max(current_box[0], next_box[0]), min(current_box[1], next_box[1])]            y_range = [max(current_box[2], next_box[2]), min(current_box[3], next_box[3])]            detail_point = ((x_range[0] + x_range[1])/2, (y_range[0] + y_range[1])/2)            new_add = sqrt((detail_points[current_box][0]+detail_point[0])**2 + (detail_points[current_box][1]+detail_point[1])**2)            new_cost = cost_so_far[current_box] + new_add            if next_box not in came_from or new_cost < cost_so_far[next_box]:                detail_points[next_box] = detail_point                cost_so_far[next_box] = new_cost                heappush(frontier, next_box)                came_from[next_box] = current_box    # UPDATE PATH    if dst_box not in came_from:        print("No path!")    else:        box_path = []        prev_box = dst_box        path.append((destination_point, detail_points[prev_box]))        while prev_box != src_box:            print(str(detail_points[prev_box])+str(detail_points[came_from[prev_box]]))            path.append((detail_points[prev_box], detail_points[came_from[prev_box]]))            prev_box = came_from[prev_box]    # RETURN VALUES    return path, boxes