def find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = []        detail_points = {}    # FIND BOXES THAT CONTAIN SRC AND DST POINTS    # iterate through list of boxes    # current search: O(n) linear search    src_box = None    dst_box = None    for box in mesh["boxes"]:        # box : (x1, x2, y1, y2)        # src_point X check        if (box[0] <= source_point[0] and source_point[0] <= box[1]):            # src_point Y check            if (box[2] <= source_point[1] and source_point[1] <= box[3]):                src_box = box        # dst_point X check        if (box[0] <= destination_point[0] and destination_point[0] <= box[1]):            # dst_point Y check            if (box[2] <= destination_point[1] and destination_point[1] <= box[3]):                dst_box = box    # return if points are inside walls    if not (src_box and dst_box):        return path, boxes    # FIND SEQUENCE OF BOXES THAT REACHES DST FROM SRC    # (src_box, dst_box, mesh)    # current search: breadth first    frontier = []    frontier.append(src_box)    came_from = {}    came_from[src_box] = None    detail_points[src_box] = source_point    # while frontier not empty    while frontier:        # dequeue item from frontier        current_box = frontier.pop(0)        boxes.append(current_box)                # early exit        #if current_box == dst_box:        #    break                # else search adjacent boxes        for next_box in mesh["adj"][current_box]:            if next_box not in came_from:                # legal line segment                 x_range = [max(current_box[0], next_box[0]), min(current_box[1], next_box[1])]                y_range = [max(current_box[2], next_box[2]), min(current_box[3], next_box[3])]                detail_points[next_box] = ((x_range[0] + x_range[1])/2, (y_range[0] + y_range[1])/2)                # add adjacents                frontier.append(next_box)                came_from[next_box] = current_box        # UPDATE PATH    if dst_box not in came_from:        print("No path!")    else:        box_path = []        prev_box = dst_box        path.append((destination_point, detail_points[prev_box]))        while not prev_box == src_box:            path.append((detail_points[prev_box], detail_points[came_from[prev_box]]))            prev_box = came_from[prev_box]    # RETURN VALUES    return path, boxes